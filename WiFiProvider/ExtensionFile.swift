//
//  ExtensionFile.swift
//  WiFiProvider
//
//  Created by gautam  on 28/04/23.
//

import Foundation
import UIKit

extension UIView {
    
    @IBInspectable var borderWidth: CGFloat {
        set {
            layer.borderWidth = newValue
        }
        get {
            return layer.borderWidth
        }
    }
    
    @IBInspectable var cornerRadius: CGFloat {
        set {
            layer.cornerRadius = newValue
        }
        get {
            return layer.cornerRadius
        }
    }
    
    @IBInspectable var borderColor: UIColor? {
        set {
            guard let uiColor = newValue else { return }
            layer.borderColor = uiColor.cgColor
        }
        get {
            guard let color = layer.borderColor else { return nil }
            return UIColor(cgColor: color)
        }
    }
}

extension CGFloat{
    func convertMeter(toMilesOrKilometer meterValue: Double, isKM isKilometer: Bool) -> CGFloat {
        var convertedValue: CGFloat
        if isKilometer == true {
            convertedValue = CGFloat(meterValue / 1000) // Result in kilometer
        } else {
            convertedValue = CGFloat(Double(meterValue) / 1609.344) // Result in miles
        }
        return convertedValue
    }
}

extension UIView {
    
    func showShadow(scale: Bool = true) {
        layer.masksToBounds = false
        layer.shadowColor = UIColor.lightGray.cgColor
        layer.shadowOpacity = 1
        layer.shadowOffset = CGSize(width: 1, height: 1)
        layer.shadowRadius = 2
        
        layer.shadowPath = UIBezierPath(rect: bounds).cgPath
        layer.shouldRasterize = true
        layer.rasterizationScale = scale ? UIScreen.main.scale : 1
    }
}

extension UIView {
    func roundCorners(corners: UIRectCorner, radius: CGFloat) {
        let path = UIBezierPath(roundedRect: bounds, byRoundingCorners: corners, cornerRadii: CGSize(width: radius, height: radius))
        let mask = CAShapeLayer()
        mask.path = path.cgPath
        layer.mask = mask
    }
}

extension UILabel {
    func textHeight(withWidth width: CGFloat) -> CGFloat {
        guard let text = text else {
            return 0
        }
        return text.height(withWidth: width, font: font)
    }
    
    func attributedTextHeight(withWidth width: CGFloat) -> CGFloat {
        guard let attributedText = attributedText else {
            return 0
        }
        return attributedText.height(withWidth: width)
    }
}

extension String {
    func height(withWidth width: CGFloat, font: UIFont) -> CGFloat {
        let maxSize = CGSize(width: width, height: CGFloat.greatestFiniteMagnitude)
        let actualSize = self.boundingRect(with: maxSize, options: [.usesLineFragmentOrigin], attributes: [.font : font], context: nil)
        return actualSize.height
    }
    
    var htmlToAttributedString: NSAttributedString? {
        guard let data = data(using: .utf8) else { return NSAttributedString() }
        do {
            return try NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding:String.Encoding.utf8.rawValue], documentAttributes: nil)
        } catch {
            return NSAttributedString()
        }
    }
    
    var htmlToString: String {
        return htmlToAttributedString?.string ?? ""
    }
    
    func toDouble() -> Double? {
        let numberFormatter = NumberFormatter()
        numberFormatter.locale = Locale(identifier: "en_US_POSIX")
        return numberFormatter.number(from: self)?.doubleValue
    }
}

extension NSAttributedString {
    func height(withWidth width: CGFloat) -> CGFloat {
        let maxSize = CGSize(width: width, height: CGFloat.greatestFiniteMagnitude)
        let actualSize = boundingRect(with: maxSize, options: [.usesLineFragmentOrigin], context: nil)
        return actualSize.height
    }
}

extension UIApplication {
    class func getTopMostViewController(base: UIViewController? = UIApplication.shared.keyWindow?.rootViewController) -> UIViewController? {
        if let nav = base as? UINavigationController {
            return getTopMostViewController(base: nav.visibleViewController)
        }
        if let tab = base as? UITabBarController {
            if let selected = tab.selectedViewController {
                return getTopMostViewController(base: selected)
            }
        }
        if let presented = base?.presentedViewController {
            return getTopMostViewController(base: presented)
        }
        return base
    }
}


extension UIView {
    func addGradientWithColor1(color: UIColor,color1: UIColor,view:UIView) {
        let gradient = CAGradientLayer()
        gradient.frame = view.bounds
        gradient.colors = [color.cgColor, color1.cgColor]

        self.layer.insertSublayer(gradient, at: 0)
    }
}
func UIColorFromHex(rgbValue:UInt32, alpha:Double=1.0)->UIColor {
    let red = CGFloat((rgbValue & 0xFF0000) >> 16)/256.0
    let green = CGFloat((rgbValue & 0xFF00) >> 8)/256.0
    let blue = CGFloat(rgbValue & 0xFF)/256.0

    return UIColor(red:red, green:green, blue:blue, alpha:CGFloat(alpha))
}

extension String {
    func trim() -> String {
        return self.trimmingCharacters(in: CharacterSet.whitespacesAndNewlines)
    }
}



func hexStringColor (hex:String) -> UIColor {
    var cString:String = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()
    
    if (cString.hasPrefix("#")) {
        cString.remove(at: cString.startIndex)
    }
    
    if ((cString.count) != 6) {
        return UIColor.gray
    }
    
    var rgbValue:UInt32 = 0
    Scanner(string: cString).scanHexInt32(&rgbValue)
    
    return UIColor(
        red: CGFloat((rgbValue & 0xFF0000) >> 16) / 255.0,
        green: CGFloat((rgbValue & 0x00FF00) >> 8) / 255.0,
        blue: CGFloat(rgbValue & 0x0000FF) / 255.0,
        alpha: CGFloat(1.0)
    )
}



func getSavedStringData(dataName: String)-> String{
    let defaults = UserDefaults.standard
    if(defaults.value(forKey: dataName) != nil){
        print("aaaaa\(defaults.value(forKey: dataName) as! String)")
        return defaults.value(forKey: dataName) as! String
        
    } else {
        return ""
    }
}






func settingPrompt(self:UIViewController){
    
    DispatchQueue.main.async {
        let alertController = UIAlertController (title: "SendAnyWhere", message: "Go to Settings?", preferredStyle: .alert)
        
        let settingsAction = UIAlertAction(title: "Settings", style: .default) { (_) -> Void in
            guard let settingsUrl = URL(string: UIApplication.openSettingsURLString) else {
                return
            }
            
            if UIApplication.shared.canOpenURL(settingsUrl) {
                UIApplication.shared.open(settingsUrl, completionHandler: { (success) in
                    print("Settings opened: \(success)")
                })
            }
        }
        alertController.addAction(settingsAction)
        let cancelAction = UIAlertAction(title: "Cancel", style: .default, handler: nil)
        alertController.addAction(cancelAction)
        
        self.present(alertController, animated: true, completion: nil)
        
    }
}




func lightTheme(){
    UIApplication.shared.windows.forEach { window in
        if #available(iOS 13.0, *) {
            window.overrideUserInterfaceStyle = .light
        } else {
            // Fallback on earlier versions
            
        }
    }
}



extension Array where Element: Equatable {
    
    // Remove first collection element that is equal to the given `object`:
    mutating func remove(object: Element) {
        guard let index = firstIndex(of: object) else {return}
        remove(at: index)
    }
    
}

typealias UnixTime = Int
extension UnixTime {
    private func formatType(form: String) -> DateFormatter {
        let dateFormatter = DateFormatter()
        dateFormatter.locale = Locale(identifier:TimeZone.timeZoneDataVersion)
        dateFormatter.dateFormat = form
        return dateFormatter
    }
    var dateFull: Date {
        return Date(timeIntervalSince1970: Double(self))
    }
    var toHour: String {
        return formatType(form: "HH:mm:ss").string(from: dateFull)
    }
    var toDay: String {
        return formatType(form: "MM/dd/yyyy").string(from: dateFull)
    }
}

protocol Dateable {
    func userFriendlyFullDate() -> String
    func userFriendlyHours() -> String
}

extension Date: Dateable {
    var  formatter: DateFormatter { return DateFormatter() }

    func userFriendlyFullDate() -> String {
      
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
        formatter.timeZone = TimeZone(abbreviation: "UTC")
        return formatter.string(from: self)
    }

    func userFriendlyHours() -> String {
        
        formatter.dateFormat = "HH:mm"
        formatter.timeZone = TimeZone(abbreviation: "UTC")
        return formatter.string(from: self)
    }
}

extension Date
{
    func toString( dateFormat format  : String ) -> String
    {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = format
        return dateFormatter.string(from: self)
    }

}

extension TimeInterval {
    var minuteSecondMS: String {
        return String(format:"%d:%02d.%03d", minute, second, millisecond)
    }
    var minute: Int {
        return Int((self/60).truncatingRemainder(dividingBy: 60))
    }
    var second: Int {
        return Int(truncatingRemainder(dividingBy: 60))
    }
    var millisecond: Int {
        return Int((self*1000).truncatingRemainder(dividingBy: 1000))
    }
}

extension Int {
    var msToSeconds: Double {
        return Double(self) / 1000
    }
}
 

extension String {
    private var convertHtmlToNSAttributedString: NSAttributedString? {
        guard let data = data(using: .utf8) else {
            return nil
        }
        do {
            return try NSAttributedString(data: data,options: [.documentType: NSAttributedString.DocumentType.html,.characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil)
        }
        catch {
            print(error.localizedDescription)
            return nil
        }
    }
    
    public func convertHtmlToAttributedStringWithCSS(font: UIFont? , csscolor: String , lineheight: Int, csstextalign: String) -> NSAttributedString? {
        guard let font = font else {
            return convertHtmlToNSAttributedString
        }
        let modifiedString = "<style>body{font-family: '\(font.fontName)'; font-size:\(font.pointSize)px; color: \(csscolor); line-height: \(lineheight)px; text-align: \(csstextalign); }</style>\(self)";
        guard let data = modifiedString.data(using: .utf8) else {
            return nil
        }
        do {
            return try NSAttributedString(data: data, options: [.documentType: NSAttributedString.DocumentType.html, .characterEncoding: String.Encoding.utf8.rawValue], documentAttributes: nil)
        }
        catch {
            print(error)
            return nil
        }
    }
}

extension NSMutableAttributedString {
    
    func setColor(color: UIColor, forText stringValue: String) {
       let range: NSRange = self.mutableString.range(of: stringValue, options: .caseInsensitive)
        self.addAttribute(NSAttributedString.Key.foregroundColor, value: color, range: range)
    }

}

let ALREADY_LOGIN = "ALREADY_LOGIN"
let USER_SKIPPED = "USER_SKIPPED"
let PROFILE_NAME = "PROFILE_NAME"
let PROFILE_IMAGE = "PROFILE_IMAGE"
let PROFILE_FIRST_TIME = "PROFILE_FIRST_TIME"
let FB_IMAGE = "FB_IMAGE"
let FIRST_TIME_ONBOARD  = "FIRST_TIME_ONBOARD"
let FIRST_TIME_HISTORY_ONBOARD  = "FIRST_TIME_HISTORY_ONBOARD"
let FIRST_TIME_RECIEVEDFILE_ONBOARD  = "FIRST_TIME_RECIEVEDFILE_ONBOARD"
let LOCAL_RECIEVE_FIRST_TIME_ONBOARD  = "LOCAL_RECIEVE_FIRST_TIME_ONBOARD"
let GLOBAL_RECIEVE_FIRST_TIME_ONBOARD  = "GLOBAL_RECIEVE_FIRST_TIME_ONBOARD"
let LOCAL_SEND_FIRST_TIME_ONBOARD  = "LOCAL_SEND_FIRST_TIME_ONBOARD"
let GLOBAL_SEND_FIRST_TIME_ONBOARD  = "GLOBAL_SEND_FIRST_TIME_ONBOARD"
let WEBSHARE_SEND_FIRST_TIME_ONBOARD  = "WEBSHARE_SEND_FIRST_TIME_ONBOARD"
let LANGUAGE_FIRST_TIME = "LANGUAGE_FIRST_TIME"
let HISTORY_FILTER_SELECTION  = "HISTORY_FILTER_SELECTION"


func statusBarColor(self:UIViewController){
    self.navigationController?.navigationBar.barStyle = .default
}
extension String {
   func maxLength(length: Int) -> String {
       var str = self
       let nsString = str as NSString
       if nsString.length >= length {
           str = nsString.substring(with:
               NSRange(
                location: 0,
                length: nsString.length > length ? length : nsString.length)
           )
       }
       return  str
   }
}

func humanReadableByteCount(bytes: Int) -> String {
    if (bytes < 1000) { return "\(bytes) B" }
    let exp = Int(log2(Double(bytes)) / log2(1000.0))
    let unit = ["KB", "MB", "GB", "TB", "PB", "EB"][exp - 1]
    let number = Double(bytes) / pow(1000, Double(exp))
    if exp <= 1 || number >= 100 {
        return String(format: "%.0f %@", number, unit)
    } else {
        return String(format: "%.1f %@", number, unit)
            .replacingOccurrences(of: ".0", with: "")
    }
}


func saveDocuments(url:URL, fileName:String) {
       DispatchQueue.main.async {
         //  let url = URL(string: urlString)
           let pdfData = try? Data.init(contentsOf: url)
           let resourceDocPath = (FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)).last! as URL
           let pdfNameFromUrl = fileName
           let actualPath = resourceDocPath.appendingPathComponent(pdfNameFromUrl)
           do {
               try pdfData?.write(to: actualPath, options: .atomic)
               print("pdf successfully saved!")
           } catch {
               print("Pdf could not be saved")
           }
       }
   }


extension UIViewController {
    public func hideDefaultNavigation() {
        self.navigationItem.setHidesBackButton(true, animated: true)
        self.navigationController?.setNavigationBarHidden(true, animated: true)
        self.navigationController?.navigationBar.isHidden = true
        self.navigationController?.isNavigationBarHidden = true
    }
    
    
    
}
public extension UIDevice {

    /// pares the deveice name as the standard name
    var userDevicemodelName: String {

        #if targetEnvironment(simulator)
            let identifier = ProcessInfo().environment["SIMULATOR_MODEL_IDENTIFIER"]!
        #else
            var systemInfo = utsname()
            uname(&systemInfo)
            let machineMirror = Mirror(reflecting: systemInfo.machine)
            let identifier = machineMirror.children.reduce("") { identifier, element in
                guard let value = element.value as? Int8 , value != 0 else { return identifier }
                return identifier + String(UnicodeScalar(UInt8(value)))
            }
        #endif

        switch identifier {
        case "iPod5,1":                                 return "iPod Touch 5"
        case "iPod7,1":                                 return "iPod Touch 6"
        case "iPhone3,1", "iPhone3,2", "iPhone3,3":     return "iPhone 4"
        case "iPhone4,1":                               return "iPhone 4s"
        case "iPhone5,1", "iPhone5,2":                  return "iPhone 5"
        case "iPhone5,3", "iPhone5,4":                  return "iPhone 5c"
        case "iPhone6,1", "iPhone6,2":                  return "iPhone 5s"
        case "iPhone7,2":                               return "iPhone 6"
        case "iPhone7,1":                               return "iPhone 6 Plus"
        case "iPhone8,1":                               return "iPhone 6s"
        case "iPhone8,2":                               return "iPhone 6s Plus"
        case "iPhone9,1", "iPhone9,3":                  return "iPhone 7"
        case "iPhone9,2", "iPhone9,4":                  return "iPhone 7 Plus"
        case "iPhone8,4":                               return "iPhone SE"
        case "iPhone10,1", "iPhone10,4":                return "iPhone 8"
        case "iPhone10,2", "iPhone10,5":                return "iPhone 8 Plus"
        case "iPhone10,3", "iPhone10,6":                return "iPhone X"
        case "iPhone11,2":                              return "iPhone XS"
        case "iPhone11,4", "iPhone11,6":                return "iPhone XS Max"
        case "iPhone11,8":                              return "iPhone XR"
        case "iPhone12,1":                              return "iPhone 11"
        case "iPhone12,3":                              return "iPhone 11 Pro"
        case "iPhone12,5":                              return "iPhone 11 Pro Max"
        case "iPad2,1", "iPad2,2", "iPad2,3", "iPad2,4":return "iPad 2"
        case "iPad3,1", "iPad3,2", "iPad3,3":           return "iPad 3"
        case "iPad3,4", "iPad3,5", "iPad3,6":           return "iPad 4"
        case "iPad4,1", "iPad4,2", "iPad4,3":           return "iPad Air"
        case "iPad5,3", "iPad5,4":                      return "iPad Air 2"
        case "iPad6,11", "iPad6,12":                    return "iPad 5"
        case "iPad7,5", "iPad7,6":                      return "iPad 6"
        case "iPad2,5", "iPad2,6", "iPad2,7":           return "iPad Mini"
        case "iPad4,4", "iPad4,5", "iPad4,6":           return "iPad Mini 2"
        case "iPad4,7", "iPad4,8", "iPad4,9":           return "iPad Mini 3"
        case "iPad5,1", "iPad5,2":                      return "iPad Mini 4"
        case "iPad6,3", "iPad6,4":                      return "iPad Pro 9.7 Inch"
        case "iPad6,7", "iPad6,8":                      return "iPad Pro 12.9 Inch"
        case "iPad7,1", "iPad7,2":                      return "iPad Pro (12.9-inch) (2nd generation)"
        case "iPad7,3", "iPad7,4":                      return "iPad Pro (10.5-inch)"
        case "iPad8,1", "iPad8,2", "iPad8,3", "iPad8,4":return "iPad Pro (11-inch)"
        case "iPad8,5", "iPad8,6", "iPad8,7", "iPad8,8":return "iPad Pro (12.9-inch) (3rd generation)"
        case "AppleTV5,3":                              return "Apple TV"
        case "AppleTV6,2":                              return "Apple TV 4K"
        case "AudioAccessory1,1":                       return "HomePod"
        default:                                        return identifier
        }
    }

    func getDeviceIcon(value: String) -> String {
        switch value {
        case DeviceName.Acer.rawValue:
            return "acer"
        case DeviceName.Apple.rawValue:
            return"apple"
        case DeviceName.Asus.rawValue:
            return "asus"
        case DeviceName.AVITA.rawValue:
            return "avita"
        case DeviceName.BlackBerry.rawValue:
            return "blackberry"
        case DeviceName.Dell.rawValue:
            return "dell"
        case DeviceName.Google.rawValue:
            return "google"
        case DeviceName.Honor.rawValue:
            return "honor"
        case DeviceName.HTC.rawValue:
            return "htc"
        case DeviceName.Huawei.rawValue:
            return "huawei"
        case DeviceName.Infinix.rawValue:
            return "infix"
        case DeviceName.Lenovo.rawValue:
            return "lenovo"
        case DeviceName.LG.rawValue:
            return "lg"
        case DeviceName.Xiaomi.rawValue:
            return "xiaomi"
        case DeviceName.Micromax.rawValue:
            return "micromax"
        case DeviceName.Microsoft.rawValue:
            return "windows"
        case DeviceName.Motorola.rawValue:
            return "motorola"
        case DeviceName.Nokia.rawValue:
            return "nokia"
        case DeviceName.OnePlus.rawValue:
            return "one_plus"
        case DeviceName.Oppo.rawValue:
            return "oppo"
        case DeviceName.Panasonic.rawValue:
            return "panasonic"
        case DeviceName.Realme.rawValue:
            return "realme"
        case DeviceName.Samsung.rawValue:
            return "samsung"
        case DeviceName.Sony.rawValue:
            return "sony"
        case DeviceName.Toshiba.rawValue:
            return "toshiba"
        case DeviceName.Vaio.rawValue:
            return "sony"
        case DeviceName.Vivo.rawValue:
            return "vivo"
        default:
            return "default_icon"
        }
    }

    func getOsIcon(value: String) -> String {
        if value.localizedCaseInsensitiveContains("Android") {
            return "android"
        } else if value.localizedCaseInsensitiveContains("Window") {
            return "windows"
        } else if value.localizedCaseInsensitiveContains("Chrome") {
            return "google"
        } else if value.localizedCaseInsensitiveContains("iOS") {
            return "apple"
        } else {
            return "default_icon"
        }
    }

    func getOsName(value: String) -> String {
        if value.localizedCaseInsensitiveContains("Android") {
            return "Android"
        } else if value.localizedCaseInsensitiveContains("Window") {
            return "Windows"
        } else if value.localizedCaseInsensitiveContains("Chrome") {
            return "Chrome"
        } else if value.localizedCaseInsensitiveContains("iOS") {
            return "iOS"
        } else {
            return "Not Found"
        }
    }

}
